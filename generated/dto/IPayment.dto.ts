
//////////////////////////////////////////////////////////////////////////////////////////
/////// THIS CODE IS AUTOGENERATED. DO NOT CHANGE!!!                             /////////
//////////////////////////////////////////////////////////////////////////////////////////
import { ApiProperty, OmitType } from "@nestjs/swagger";
      import { Type } from "class-transformer";
      import { Validate, IsBoolean, ValidationArguments, ValidatorConstraint, ValidatorConstraintInterface, IsDefined, IsNotEmptyObject, IsObject, ValidateNested } from "class-validator";

      

///////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// CUSTOM VALIDATORS ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Validator constraint if the given value is a number or 0x-prefixed hexadecimal string.
 */
@ValidatorConstraint({ name: "unsigned-int", async: false })
class IsUnsignedIntLike implements ValidatorConstraintInterface {
  /**
   * Validates if the given value is a string of decimal unsigned number or 0x-prefixed hexadecimal string.
   * @param text
   * @param args
   * @returns
   */
  validate(text: any, _args: ValidationArguments) {
    return typeof text === "string" && (/^0x[0-9a-fA-F]+$/i.test(text) || /^[0-9]+$/i.test(text));
  }

  /**
   * Returns the default error message template.
   * @param args
   * @returns
   */
  defaultMessage(_args: ValidationArguments) {
    return "($property) value ($value) is not a decimal number in string or 0x-prefixed hexadecimal string";
  }
}

/**
 * Validator constraint if the given value is a number or 0x-prefixed hexadecimal string.
 */
@ValidatorConstraint({ name: "signed-int", async: false })
class IsSignedIntLike implements ValidatorConstraintInterface {
  /**
   * Validates if the given value is a number or 0x-prefixed hexadecimal string.
   * @param text
   * @param args
   * @returns
   */
  validate(text: any, _args: ValidationArguments) {
    return typeof text === "string" && (/^-?0x[0-9a-fA-F]+$/i.test(text) || /^-?[0-9]+$/i.test(text));
  }

  /**
   * Returns the default error message template.
   * @param args
   * @returns
   */
  defaultMessage(_args: ValidationArguments) {
    return "($property) value ($value) is not a signed decimal integer in string or signed 0x-prefixed hexadecimal string";
  }
}

/**
 * Validator constraint if the given value is a 0x-prefixed hexadecimal string representing 32 bytes.
 */
@ValidatorConstraint({ name: "hash-32", async: false })
class IsHash32 implements ValidatorConstraintInterface {
  /**
   * Validates if the given value is a 0x-prefixed hexadecimal string representing 32 bytes.
   * @param text
   * @param args
   * @returns
   */
  validate(text: any, _args: ValidationArguments) {
    return typeof text === "string" && /^0x[0-9a-f]{64}$/i.test(text);
  }

  /**
   * Returns the default error message template.
   * @param args
   * @returns
   */
  defaultMessage(_args: ValidationArguments) {
    return "($property) value ($value) is not 0x-prefixed hexadecimal string representing 32 bytes";
  }
}


/**
 * Validator constraint if the given value is a 0x-prefixed hexadecimal string
 */
@ValidatorConstraint({ name: "hash-0x", async: false })
class Is0xHex implements ValidatorConstraintInterface {
  /**
   * Validates if the given value is a 0x-prefixed hexadecimal string 
   * @param text
   * @param args
   * @returns
   */
  validate(text: any, _args: ValidationArguments) {
    return typeof text === "string" && /^0x[0-9a-f]+$/i.test(text);
  }

  /**
   * Returns the default error message template.
   * @param args
   * @returns
   */
  defaultMessage(_args: ValidationArguments) {
    return "($property) value ($value) is not 0x-prefixed hexadecimal string";
  }
}


/**
 * Validator constraint if the given value is an EVM address, hence 0x-prefixed hexadecimal string representing 20 bytes.
 */
@ValidatorConstraint({ name: "evm-address", async: false })
class IsEVMAddress implements ValidatorConstraintInterface {
  /**
   * Validates if the given value is an EVM address, hence 0x-prefixed hexadecimal string representing 20 bytes.
   * @param text
   * @param args
   * @returns
   */
  validate(text: any, _args: ValidationArguments) {
    return typeof text === "string" && /^0x[0-9a-f]{40}$/i.test(text);
  }

  /**
   * Returns the default error message template.
   * @param args
   * @returns
   */
  defaultMessage(_args: ValidationArguments) {
    return "($property) value ($value) is not 0x-prefixed hexadecimal string representing 20 bytes (EVM address)";
  }
}


///////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// DTOs /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Attestation status
 */
export enum AttestationResponseStatus {
    /**
     * Attestation request is valid.
     */
    VALID = "VALID",
    /**
     * Attestation request is invalid.
     */
    INVALID = "INVALID",
    /**
     * Attestation request cannot be confirmed neither rejected by the verifier at the moment.
     */
    INDETERMINATE = "INDETERMINATE",
}


  /**
  * Attestation response for specific attestation type (flattened)
  */
  export class AttestationResponseDTO_IPayment_Response {
    constructor(params: Required<AttestationResponseDTO_IPayment_Response>) {
        Object.assign(this, params);
    }

    status: AttestationResponseStatus;

    response?: IPayment_Response;
  }
  


export class IPayment_ResponseBody {
         constructor(params: Required<IPayment_ResponseBody>) {
            Object.assign(this, params);
          }         
   
      /**
* Number of the block in which the transaction is included.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `Number of the block in which the transaction is included.`, example: "123"})
blockNumber: string;

      /**
* The timestamp of the block in which the transaction is included.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `The timestamp of the block in which the transaction is included.`, example: "123"})
blockTimestamp: string;

      /**
* Standard address hash of the source address.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `Standard address hash of the source address.`, example: "0x0000000000000000000000000000000000000000000000000000000000000000"})
sourceAddressHash: string;

      /**
* Standard address hash of the receiving address.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `Standard address hash of the receiving address.`, example: "0x0000000000000000000000000000000000000000000000000000000000000000"})
receivingAddressHash: string;

      /**
* Standard address hash of the intended receiving address.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `Standard address hash of the intended receiving address.`, example: "0x0000000000000000000000000000000000000000000000000000000000000000"})
intendedReceivingAddressHash: string;

      /**
* Amount in minimal units spent by the source address.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `Amount in minimal units spent by the source address.`, example: "123"})
spentAmount: string;

      /**
* Amount in minimal units to be spent by the source address.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `Amount in minimal units to be spent by the source address.`, example: "123"})
intendedSpentAmount: string;

      /**
* Amount in minimal units received by the receiving address.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `Amount in minimal units received by the receiving address.`, example: "123"})
receivedAmount: string;

      /**
* Amount in minimal units intended to be received by the receiving address.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `Amount in minimal units intended to be received by the receiving address.`, example: "123"})
intendedReceivedAmount: string;

      /**
* Standard payment reference of the transaction.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `Standard payment reference of the transaction.`, example: "0x0000000000000000000000000000000000000000000000000000000000000000"})
standardPaymentReference: string;

      /**
* Indicator whether only one source and one receiver are involved in the transaction.
*/
      @IsBoolean()
      @ApiProperty({description: `Indicator whether only one source and one receiver are involved in the transaction.`, example: true})
oneToOne: boolean;

      /**
* Succes status of the transaction: 0 - success, 1 - failed by sender's fault,
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `Succes status of the transaction: 0 - success, 1 - failed by sender's fault,`, example: "123"})
status: string;
}
export class IPayment_RequestBody {
         constructor(params: Required<IPayment_RequestBody>) {
            Object.assign(this, params);
          }         
   
      /**
* ID of the payment transaction.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `ID of the payment transaction.`, example: "0x0000000000000000000000000000000000000000000000000000000000000000"})
transactionId: string;

      /**
* For UTXO chains, this is the index of the transaction input with source address.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `For UTXO chains, this is the index of the transaction input with source address.`, example: "123"})
inUtxo: string;

      /**
* For UTXO chains, this is the index of the transaction output with receiving address.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `For UTXO chains, this is the index of the transaction output with receiving address.`, example: "123"})
utxo: string;
}
export class IPayment_Request {
         constructor(params: Required<IPayment_Request>) {
            Object.assign(this, params);
          }         
   
      /**
* ID of the attestation type.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `ID of the attestation type.`, example: "0x495061796d656e74000000000000000000000000000000000000000000000000"})
attestationType: string;

      /**
* ID of the data source.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `ID of the data source.`, example: "0x4254430000000000000000000000000000000000000000000000000000000000"})
sourceId: string;

      /**
* `MessageIntegrityCode` that is derived from the expected response.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `'MessageIntegrityCode' that is derived from the expected response.`, example: "0x0000000000000000000000000000000000000000000000000000000000000000"})
messageIntegrityCode: string;

   /**
* Data defining the request. Type (struct) and interpretation is determined
*/
   @ValidateNested()
        @Type(() => IPayment_RequestBody)
        @IsDefined()
@IsNotEmptyObject()
   @IsObject()   
  
   @ApiProperty({description: `Data defining the request. Type (struct) and interpretation is determined`})
requestBody: IPayment_RequestBody;
}
export class IPayment_Response {
         constructor(params: Required<IPayment_Response>) {
            Object.assign(this, params);
          }         
   
      /**
* Extracted from the request.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `Extracted from the request.`, example: "0x495061796d656e74000000000000000000000000000000000000000000000000"})
attestationType: string;

      /**
* Extracted from the request.
*/
      @Validate(IsHash32)
      @ApiProperty({description: `Extracted from the request.`, example: "0x4254430000000000000000000000000000000000000000000000000000000000"})
sourceId: string;

      /**
* The ID of the State Connector round in which the request was considered.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `The ID of the State Connector round in which the request was considered.`, example: "123"})
votingRound: string;

      /**
* The lowest timestamp used to generate the response.
*/
      @Validate(IsUnsignedIntLike)
      @ApiProperty({description: `The lowest timestamp used to generate the response.`, example: "123"})
lowestUsedTimestamp: string;

   /**
* Extracted from the request.
*/
   @ValidateNested()
        @Type(() => IPayment_RequestBody)
        @IsDefined()
@IsNotEmptyObject()
   @IsObject()   
  
   @ApiProperty({description: `Extracted from the request.`})
requestBody: IPayment_RequestBody;

   /**
* Data defining the response. The verification rules for the construction
*/
   @ValidateNested()
        @Type(() => IPayment_ResponseBody)
        @IsDefined()
@IsNotEmptyObject()
   @IsObject()   
  
   @ApiProperty({description: `Data defining the response. The verification rules for the construction`})
responseBody: IPayment_ResponseBody;
}
export class IPayment_Proof {
         constructor(params: Required<IPayment_Proof>) {
            Object.assign(this, params);
          }         
   
      /**
* Merkle proof corresponding to the attestation response.
*/
      @Validate(IsHash32, {each: true})
      @ApiProperty({description: `Merkle proof corresponding to the attestation response.`, example: ["0x0000000000000000000000000000000000000000000000000000000000000000"]})
merkleProof: string[];

   /**
* Attestation response.
*/
   @ValidateNested()
        @Type(() => IPayment_Response)
        @IsDefined()
@IsNotEmptyObject()
   @IsObject()   
  
   @ApiProperty({description: `Attestation response.`})
data: IPayment_Response;
}

export class IPayment_RequestNoMic extends OmitType<IPayment_Request, "messageIntegrityCode">(IPayment_Request, ['messageIntegrityCode'] as const) {}

